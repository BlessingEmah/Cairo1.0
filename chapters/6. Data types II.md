# Data Types: Enums and Pattern Matching

In this section, we would be talking about Enums and Pattern Matching, an alternative conditional statements that is works really well with Enums.

## Enums

Enums are custom types that allows the creation of variants of a value under a single name.

Take, for instance, for an exam test, you are expected to either pass or fail and nothing else. Let's create an enum for that.

```
enum ExamResult {
    Pass: (),
    Fail: ()
}
```

`Pass` and `Fail` has null(not a type in Cairo) types here. But, we could have an enum whose variants has different types. Like, so:

```
enum Message {
    Quit: (),
    Echo: felt252,
    Move: (u32, u32),
    ChangeColor: (u8, u8, u8)
}
```

## Pattern Matching

Now, imagine remarks were been given for the based on `ExamResult` we mentioned above, the best-known way to do this would be to use `if statements` but here we would use `pattern matching` instead.

Here's how we would do it.

```
use debug::PrintTrait;

fn give_remark(result: ExamResult){
    match result {
        ExamResult::Pass => {
            ('Congratulations. You passed').print()
        },
        ExamResult::Fail => {
            ('Sorry. You didn't make it').print()
        }
    }
}
```

- `use debug::PrintTrait` gives us the `print()` function
