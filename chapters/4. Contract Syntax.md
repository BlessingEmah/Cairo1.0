# Cairo Program, Starknet Contracts and Contract Syntax

In this section, we will explore the key concepts of the Cairo programming language and the StarkNet, including Cairo programs, StarkNet contracts, and the syntax used to write contracts for execution on the StarkNet.

## Cairo Program

A Cairo program is a sequence of instructions written in the Cairo programming language that specifies a set of computations to be executed. It can be used for a variety of purposes, such as cryptography. A Cairo program can be executed on any system that supports the Cairo programming language.


## StarkNet Contract

A StarkNet contract, on the other hand, is a specific type of smart contract designed to run on  StarkNet. A StarkNet contract is written in the Cairo programming language and specifies a set of rules and behaviors that govern the interactions between the contract and the users or other contracts that interact with it on the StarkNet ecosystem.


In summary, the Cairo programming language provides a flexible and expressive toolset for creating programs and smart contracts, while StarkNet  provides a specialized environment for executing Cairo contracts with a focus on scalability, security, and efficiency.

## Contract Syntax

In the following code, we will analyze a basic Ens contract. This contract allows users to assign a name to their contract address. We will examine key concepts in the code such as imports, decorators, state variables, and how to read and write to the contract storage.

```
#[contract]
mod ENS{
use starknet::{get_caller_address, ContractAddress};

struct Storage{
names: LegacyMap::<ContractAddress, felt252>,
}

#[event]
fn stored_name(caller:ContractAddress, name:felt252){}


#[external]
fn store_name(_name:felt252){
let caller = get_caller_address();
names::write(caller, _name);
stored_name(caller,_name);
}

#[view]
fn get_name(_address:ContractAddress) -> felt252{
let name = names::read(_address);
return name;
}

 }

```


## Decorators

In StarkNet contracts, decorators are special annotations that modify the behavior of certain functions or methods. Decorators are placed before a function or method and begin with the `#[` symbol.

The followings are decorators commonly used in StarkNet contracts:

`#[contract]`: This decorator is used to mark a module as a StarkNet contract. It informs the compiler that the module should be compiled and deployed to the StarkNet network.

`#[constructor]`: This decorator allows the function to be called with any necessary arguments to initialize the contract's state variables.

`#[external]`: This decorator is used to mark a function as an external function that can be called from outside the contract. External functions are typically used to modify the contract state or emit events.

`#[view]`: This decorator is used to mark a function as a view function that can be called from outside the contract to read data from the contract storage. View functions do not modify the contract state or emit events.

`#[event]`: define events that can be emitted by the contract


## Imports

Imports are statements that allow the contract to use external modules and their associated functionality. Import statements are typically placed at the top of a contract file, before the module definition.

we use the `use` keyword to import the `get_caller_address` and `ContractAddress` from the starknet library. These functions are used to retrieve the address of the caller and the address of the contract, respectively. By importing these functions, we make them available for use in our contract without having to define them ourselves.

```
use starknet::{get_caller_address, ContractAddress};
```

## State Variables

State variables are variables that store data that can be accessed and modified throughout the lifetime of the contract. These variables are declared within the `struct` block of a module and are stored in the contract's persistent storage.

```
struct Storage{
names: LegacyMap::<ContractAddress, felt252>,
}
```

## Writing to storage

```
 #[external]
    fn store_name(_name: felt252) {
        let caller = get_caller_address();
        names::write(caller, _name);
        stored_name(caller, _name);
    }

```


The `store_name` function is used to write a name to the contract storage for a given address. Here's how this function works:

- The `get_caller_address` function is used to retrieve the address of the caller, which is then stored in the caller variable.
- The `names::write(caller, _name)` statement writes the given `_name` value to the contract storage for the caller address. The names variable refers to a state variable of the Storage struct that stores the mapping of names to contract addresses.
- The `stored_name(caller, _name)` statement emits a `stored_name` event with the caller address and the `_name` value as arguments. This event is emitted to the StarkNet network, allowing other contracts and external clients to receive notifications when a `name` is stored in the contract storage.

Overall, the `store_name` function allows a user to specify a name for their contract address and store it in the contract storage. By writing the name to the contract storage.

## Reading from storage

```
#[view]
    fn get_name(_address: ContractAddress) -> felt252 {
        let name = names::read(_address);
        return name;
    }

```

- The `get_name` function is used to read a `name` from the contract storage for a given contract address. Here's how this function works:

- The `_address` parameter specifies the `contract address` for which to retrieve the name.
- The `names::read(_address)` statement reads the `name` from the contract storage for the specified `_address`. The `names` variable refers to a state variable of the Storage struct that stores the mapping of `names` to contract addresses.
- The `name` variable stores the value that was read from the contract storage.
Finally, the `name` variable is returned to the `caller` of the function.


