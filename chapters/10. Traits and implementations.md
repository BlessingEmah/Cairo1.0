In Cairo, `traits` and `implementations` are used to define and implement functionality that can be used across different `types`.

It's very similar to interfaces in traditional Object Oriented(OO) languages, but with some key differences,in Cario, you can think of a trait as an interface for a specific type.

we define a trait by using the `trait` keyword followed by the name of the `trait`. In the trait block, we specify the signature of the functions that we want that specific trait to implement. Traits define a set of methods that must be implemented by any component that uses the trait. Here is an example of a simple trait definition in Cairo:

```
trait Maths {
   fn add() -> usize;
}
```

This `trait`, called `Maths`, defines a single method called `add`in other words we saying that every `type` that uses this trait needs to implement the add function.

`traits` can have mutliple functions it implements, for example, we can update the `trait`(Maths) above to somthing like:

```
trait Maths {
fn add() -> usize;
fn subtract() -> felt;
fn multiply() -> u8;
}

```

If a type wants to implement `trait`, it will implement all the functions declared by the `trait` otherwise, our compiler will complain.

Implementations are used to define the behavior of a `type` that uses a `trait`. The `impl` keyword is used to define implementations on traits. Trait implementations are used to implement a specific behavior for a trait, meaning that all the functions from the trait must be implemented.

Here is a simple implementation of the `Maths trait` above with only one function:

```

impl TheMaths of Maths {
fn add() -> usize {
3_usize
}
}

fn main() -> usize {
Maths::add() // returns 3_usize
}

```
